<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>JPR's Tech Notes</title><link href="http://jpiramirez.github.io/" rel="alternate"></link><link href="http://jpiramirez.github.io/feeds/ros.atom.xml" rel="self"></link><id>http://jpiramirez.github.io/</id><updated>2015-12-17T19:30:00-06:00</updated><entry><title>Writing a clock server for ROS simulations</title><link href="http://jpiramirez.github.io/ros-clockserver.html" rel="alternate"></link><updated>2015-03-20T12:00:00-05:00</updated><author><name>Juan-Pablo Ramirez</name></author><id>tag:jpiramirez.github.io,2016-03-20:ros-clockserver.html</id><summary type="html">&lt;p&gt;One advantage of using &lt;a href="http://ros.org"&gt;ROS&lt;/a&gt; is the fact that nodes &lt;a href="http://wiki.ros.org/roscpp/Overview/Time"&gt;can be agnostic to the source of their timing signals&lt;/a&gt;. The ROS system calls such as &lt;code&gt;ros::Time::now()&lt;/code&gt; from roscpp will grab the current time stamp from the OS clock or from a simulated &lt;code&gt;/clock&lt;/code&gt; signal, depending on the availability of &lt;code&gt;/clock&lt;/code&gt; and on the parameter &lt;code&gt;/use_sim_time&lt;/code&gt;. Users can force their nodes to query the OS for the current time by using functions from the &lt;code&gt;ros::WallTime*&lt;/code&gt; types.&lt;/p&gt;
&lt;p&gt;A commonly used simulated clock source comes from Gazebo, which will always publish &lt;code&gt;/clock&lt;/code&gt;. But sometimes Gazebo can consume resources that are better used somewhere else. Besides, it is interesting to write a node whose sole purpose is to publish messages to &lt;code&gt;/clock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;/clock&lt;/code&gt; topic is of type &lt;code&gt;rosgraph_msgs/Clock&lt;/code&gt;, and it simply consists of a single time stamp. The time data type is just two integers, one for seconds and another for nanoseconds. Implementing a clock server simply consists of using functions from the &lt;code&gt;ros::WallTime*&lt;/code&gt; types to read the base time signal, process that signal by multiplying or dividing it by some factor, and publishing the &lt;code&gt;rosgraph_msgs/Clock&lt;/code&gt; messages that result. More details about clock messages can be found &lt;a href="http://wiki.ros.org/Clock"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example of a clock server.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Clock server&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Juan Pablo Ramirez &amp;lt;pablo.ramirez@utdallas.edu&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;// The University of Texas at Dallas&lt;/span&gt;
&lt;span class="c1"&gt;// Sensing, Robotics, Vision, Control and Estimation Lab&lt;/span&gt;
&lt;span class="c1"&gt;// (SeRViCE) 2012-2016&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;ros/ros.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;rosgraph_msgs/Clock.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;clockserver&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;NodeHandle&lt;/span&gt; &lt;span class="n"&gt;nh_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Publisher&lt;/span&gt; &lt;span class="n"&gt;clockpub&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;tfactor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;realfactor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;WallTimer&lt;/span&gt; &lt;span class="n"&gt;timer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nl"&gt;public:&lt;/span&gt;
&lt;span class="n"&gt;clockserver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;nh_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;timefactor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tfactor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tfactor&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;tfactor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;clockpub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nh_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;advertise&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;rosgraph_msgs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Clock&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/clock&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ROS_INFO_STREAM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Clock server created&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;nh_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tickspersec&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;realfactor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;250.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;timer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nh_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createWallTimer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;WallDuration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;realfactor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;clockserver&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;broadcastTime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nsec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;clockserver&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;broadcastTime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;WallTimerEvent&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;te&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Duration&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tfactor&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;realfactor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ctime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;rosgraph_msgs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="n"&gt;clockmsg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;clockmsg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;clockmsg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nsec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nsec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;clockpub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clockmsg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;clockserver&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;clockserver&lt;/span&gt; &lt;span class="n"&gt;dr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ros&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;spin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the code two parameters are read: &lt;code&gt;timefactor&lt;/code&gt; is the speed-up or slow-down of the simulated clock signal with respect to "wall" time, and &lt;code&gt;tickspersec&lt;/code&gt; is the frequency with which the simulated clock signal will be publish (relative to wall time). This last parameter is important, because the nodes that use the &lt;code&gt;/clock&lt;/code&gt; signal may need specific frequencies depending on the application. This is equivalent to the &lt;code&gt;real_time_update_rate&lt;/code&gt; from Gazebo world files.&lt;/p&gt;</summary><category term="robotics"></category><category term="ros"></category><category term="cpp"></category></entry><entry><title>Lowering the computational load from Gazebo</title><link href="http://jpiramirez.github.io/gazebo-speedup.html" rel="alternate"></link><updated>2015-12-17T19:30:00-06:00</updated><author><name>Juan-Pablo Ramirez</name></author><id>tag:jpiramirez.github.io,2015-12-17:gazebo-speedup.html</id><summary type="html">&lt;p&gt;The &lt;a href="http://gazebosim.org/"&gt;Gazebo&lt;/a&gt; simulator is a great platform for algorithm testing, and it is very easy to use through &lt;a href="http://ros.org"&gt;ROS&lt;/a&gt;. However, Gazebo is quite precise in its calculations by default, which is sometimes cause for slowdowns. This happens often when attempting to simulate multiple robots at once.&lt;/p&gt;
&lt;p&gt;Here are some tips to reduce the load of the simulator when dealing with these situations.&lt;/p&gt;
&lt;h3&gt;Reduce the sampling rate and change the ODE solver&lt;/h3&gt;
&lt;p&gt;It seems that the default settings for Gazebo try to get the simulation running at 1 KHz, which quite frankly is a very fast sampling rate, considering the complexity of some simulation scenarios. One first step to reduce the load from Gazebo would be to reduce this rate by half or even more. It is also possible to choose a different ODE solver. I do not know the specifics of the "quick" solver, but it does seem faster and less accurate.&lt;/p&gt;
&lt;p&gt;The aforementioned changes can be done by modifying the .world file for our simulation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;physics&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ode&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;max_step_size&amp;gt;&lt;/span&gt;0.004000&lt;span class="nt"&gt;&amp;lt;/max_step_size&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;real_time_factor&amp;gt;&lt;/span&gt;1.000000&lt;span class="nt"&gt;&amp;lt;/real_time_factor&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;real_time_update_rate&amp;gt;&lt;/span&gt;250.000000&lt;span class="nt"&gt;&amp;lt;/real_time_update_rate&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;gravity&amp;gt;&lt;/span&gt;0.000000 0.000000 -9.800000&lt;span class="nt"&gt;&amp;lt;/gravity&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;ode&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;solver&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;type&amp;gt;&lt;/span&gt;quick&lt;span class="nt"&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;iters&amp;gt;&lt;/span&gt;200&lt;span class="nt"&gt;&amp;lt;/iters&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/solver&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/ode&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/physics&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The real_time_factor tag specifies how fast the simulation should run, with respect to real (wall) time. Keeping it as 1 means that Gazebo will try to run the simulation in "real time", but that is not guaranteed and depends on the system load. &lt;/p&gt;
&lt;p&gt;The tags max_step_size and real_time_update_rate should multiply to real_time_factor. In the code snippet we see that the simulation update rate is now 250 Hz, which should be handled a bit better than 1 KHz. An important caveat: if you are using your own controllers for a robot you will have to adjust your gains to the modified sampling rates.&lt;/p&gt;
&lt;h3&gt;Change the sampling rate from the sensors&lt;/h3&gt;
&lt;p&gt;Some simulated sensors can cause a huge load on the system. Cameras, RGB-D sensors and lidars are examples of this. Sometimes the default configuration files for such sensors will have values that are aimed at providing accuracy or precision. It may be the case that our application can get away with much lower sampling rates, especially if the robot dynamics are "slow". In such cases, we can configure the sensors for slower sampling.&lt;/p&gt;
&lt;p&gt;Here is an example from one of the .xacro files I use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;xacro:include&lt;/span&gt; &lt;span class="na"&gt;filename=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;$(find hector_sensors_description)/urdf/generic_camera.urdf.xacro&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;xacro:generic_camera&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;downward_cam&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;parent=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;base_link&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;ros_topic=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;camera/image&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;cam_info_topic=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;camera/camera_info&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;update_rate=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;10&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;res_x=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;640&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;res_y=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;480&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;image_format=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;R8G8B8&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;hfov=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;49.1343426412&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This snippet depends on the ROS package hector_sensors_description. The important attribute here is update_rate, from the xacro:generic_camera tag. The original value was 25 Hz and I lowered it to 10 Hz. Since my simulation is using four of these cameras, changing this parameter smoothed things quite a bit. My application may even let me lower it to 5 Hz, but 10 Hz provides a good balance. &lt;/p&gt;
&lt;h3&gt;Simplify the world as much as possible&lt;/h3&gt;
&lt;p&gt;While simulations that use digital elevation maps and detailed 3D environments are very pleasing to the eye, they may also be unnecessarily slow. If you can get away with simpler meshes and less textures, you could get nice benefits in execution rates.&lt;/p&gt;
&lt;p&gt;If you want to take this notion to the extreme, you can run Gazebo in headless mode and avoid any visualization slowdowns. This can also help if your graphics card is lacking rendering power. Let's look at a snippet from one of my .launch files.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;include&lt;/span&gt; &lt;span class="na"&gt;file=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;$(find gazebo_ros)/launch/empty_world.launch&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;arg&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;world_name&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;default=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;$(find service_utd)/worlds/service.world&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;arg&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;headless&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;arg&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;gui&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;false&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The package service_utd contains my world files. The important part here are the arguments headless and gui. Note that while we enable the headless mode, the GUI has to be turned off like this or it will start anyway.&lt;/p&gt;</summary><category term="robotics"></category><category term="gazebo"></category></entry></feed>